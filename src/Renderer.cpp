#include <Arduino.h>
#include <stdio.h>
#include "renderer.hpp"
#include "custom_functions/get_digit_from_left.hpp"

renderer::renderer(MD_MAX72XX &matrix) : _matrix(matrix)
{
  memset(_current_frame, false, sizeof(_current_frame));
  memset(_previous_frame, false, sizeof(_previous_frame));
}

void renderer::init()
{
  _matrix.begin();
  _matrix.control(MD_MAX72XX::UPDATE, MD_MAX72XX::ON);
  _matrix.clear();
}

void renderer::show()
{
  for (size_t y = 0; y < _height; y++)
    for (size_t x = 0; x < _width; x++)
    {
      size_t index = x + y * _width;
      if (_previous_frame[index] != _current_frame[index])
        _matrix.setPoint(x, y, _current_frame[index]);
      _previous_frame[index] = _current_frame[index];
      _current_frame[index] = false;
    }
}

void renderer::render(const brick &brick)
{
  for (int y = 0; y < brick._height; y++)
    for (int x = 0; x < brick._width; x++)
      if (brick.pixel_at(x, y) == brick::pixel_info::TRUE)
        render(brick.x() + x, brick.y() + y);
}

bool renderer::render(int x, int y)
{
  if (x >= 0 && static_cast<size_t>(x) < _width && y >= 0 && static_cast<size_t>(y) < _height)
  {
    _current_frame[x + y * _width] = true;
    return true;
  }
  return false;
}

void renderer::clear()
{
  _matrix.clear();
}

bool renderer::render_line(int y, uint8_t hex)
{
  if (y < 0 || static_cast<size_t>(y) >= _height)
    return false;
  for (int x = 0; x < 8; x++)
    _current_frame[x + y * _width] = (hex >> x) & 0x01;
  return true;
}

bool renderer::render(const char *string)
{
  // calculate length only if given pointer isn't NULL
  size_t str_length = string ? strlen(string) : 0;

  if (string)
  {
    // from now only only work with buffer - all chars are lower case
    // we will render only letters, digits and spaces
    if (is_string_valid(string, str_length))
    {
      for (size_t row = 0; row < _height + str_length * _letter_height; row++)
      {
        for (size_t current_char = 0; current_char < str_length; current_char++)
        {
          int top_row_index = static_cast<int>(row) - static_cast<int>(current_char) * static_cast<int>(_letter_height);

          char c = string[current_char];

          bool is_digit = isdigit(c);
          bool is_alpha = isalpha(c);
          bool is_upper = isupper(c);

          for (size_t i = 0; i < _letter_height; i++)
          {
            int y = top_row_index - static_cast<int>(i);
            if (is_digit)
              render_line(y, _digits[c - '0'][i]);
            else if (is_alpha)
            {
              if (is_upper)
                render_line(y, _aplhabet[c - 'A'][i]);
              else
                render_line(y, _aplhabet[c - 'a'][i]);
            }
            else
              render_line(y, 0); // this means it was a space
          }
        }
        show();
        delay(200);
      }
    }
  }
  return false;
}

void renderer::render(int number)
{
  char buffer[10];
  sprintf(buffer, "%d", number);
  render(buffer);
}

bool renderer::is_string_valid(const char *string, size_t length)
{
  if (!length)
    length = strlen(string);

  // dont accept if its not digit, alpha nor space
  for (size_t i = 0; i < length; i++)
    if (!isalnum(string[i]) && string[i] != ' ')
      return false;

  return true;
}

const uint8_t renderer::_aplhabet[26][8] = {
    {0x18, 0x24, 0x42, 0x42, 0x7e, 0x42, 0x42, 0xe7},
    {0xfc, 0x42, 0x44, 0x7e, 0x41, 0x41, 0x41, 0xfe},
    {0x3d, 0x43, 0x81, 0x80, 0x80, 0x81, 0x43, 0x3d},
    {0xfc, 0x42, 0x41, 0x41, 0x41, 0x41, 0x42, 0xfc},
    {0xff, 0x41, 0x40, 0x70, 0x40, 0x40, 0x41, 0xff},
    {0xff, 0x41, 0x41, 0x48, 0x78, 0x48, 0x40, 0xe0},
    {0x3f, 0x41, 0x80, 0x9f, 0x91, 0x81, 0x41, 0x3e},
    {0xe7, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0xe7},
    {0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c},
    {0x3f, 0x04, 0x04, 0x04, 0xc4, 0x84, 0x84, 0x78},
    {0xef, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0xe7},
    {0xe0, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0xfe},
    {0xc7, 0x6a, 0x52, 0x52, 0x42, 0x42, 0x42, 0xe7},
    {0xc7, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x42, 0xe7},
    {0x3c, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3c},
    {0xfe, 0x41, 0x41, 0x41, 0x7e, 0x40, 0x40, 0xe0},
    {0x7e, 0x81, 0x81, 0x81, 0x81, 0x91, 0x7e, 0x10},
    {0xfe, 0x41, 0x41, 0x41, 0x7e, 0x44, 0x42, 0xe7},
    {0x7d, 0x83, 0x81, 0x7c, 0x02, 0x81, 0xc1, 0xbe},
    {0xff, 0x89, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c},
    {0xe7, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c},
    {0xe7, 0x42, 0x42, 0x42, 0x22, 0x24, 0x14, 0x08},
    {0xe7, 0x42, 0x42, 0x42, 0x52, 0x52, 0x52, 0x2c},
    {0xe7, 0x42, 0x24, 0x18, 0x24, 0x24, 0x42, 0xe7},
    {0xe7, 0x42, 0x24, 0x14, 0x08, 0x08, 0x08, 0x1c},
    {0xff, 0x82, 0x84, 0x08, 0x10, 0x21, 0x41, 0xff}};

const uint8_t renderer::_digits[10][8] = {
    {0x3c, 0x42, 0x85, 0x89, 0x91, 0xa1, 0x42, 0x3c},
    {0x30, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0xff},
    {0x7e, 0x81, 0x01, 0x06, 0x18, 0x61, 0x81, 0xff},
    {0x7e, 0x81, 0x81, 0x0e, 0x01, 0x81, 0x81, 0x7e},
    {0x06, 0x0a, 0x12, 0x22, 0x42, 0xff, 0x02, 0x07},
    {0xff, 0x81, 0x80, 0xfe, 0x01, 0x81, 0x81, 0x7e},
    {0x7e, 0x81, 0x80, 0xfe, 0x81, 0x81, 0x81, 0x7e},
    {0xff, 0x81, 0x02, 0x04, 0x08, 0x10, 0x10, 0x38},
    {0x7e, 0x81, 0x81, 0x7e, 0x81, 0x81, 0x81, 0x7e},
    {0x7e, 0x81, 0x81, 0x7f, 0x01, 0x01, 0x81, 0x7e}};